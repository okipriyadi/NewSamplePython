Request Objects
----------------
GET and POST Dictionaries
-------------------------
The most commonly accessed pieces of request-related data Web developers use are the
GET and POST data structures, which are attributes of the HttpRequest object
( request.GET and request.POST , as you can expect) and are represented as Python dic-
tionaries.Although identical in structure, they are populated in two different ways, the
importance of which is more than you can expect at first.Together, they offer a flexible
way to parameterize Web requests.

Note
Although closely related to Python’s dict builtin, HttpRequest ’s GET and POST attributes
are actually instances of a Django-specific dict subclass, QueryDict , which is designed to
mimic the underlying behavior of these data structures in the HTTP CGI specification. All key-
value pairs store the value as a list, even in the case of a single value per key to correctly
handle the cases where the HTTP server does return multiple values. Typical use of
QueryDict s as dictionaries returns single items for convenience; you can use QueryDict
methods, such as getlist , when you’re interested in multiple values.

GET parameters are passed as part of the URL string, but are not technically part of
the URL itself in that they do not define a different resource (or view) but only change
the behavior of the resource they’re attached to. For example, the URL /userlist/ can
point to a page that lists the users of a community Web site; if the developer wants to
break the list so it isn’t gigantic, he can decide to note the page number as a GET variable:
/userlist/?page=2 .The view being accessed is still the same, but the developer can look
for a page key/value pair in the GET dictionary and return the correct page, such as in
this abstract example.
==============================================================+
def userlist(request):
	return paginated_userlist_page(page=request.GET[‘page’])
==============================================================+
Note with request.GET , as with the other dict-like attributes of the request object, it’s
helpful to make use of dictionary methods such as get (see Chapter 1 “Practical Python
for Django,” for a refresher on dictionaries), so your logic doesn’t break down when the
parameter you’re looking for isn’t specified.


POST parameters are not part of the URL but are effectively hidden from the user,
often generated by an HTML form within a Web page. One of the attributes of the FORM
tag, action , denotes which URL the data will be submitted to; if the user submits the
form, the URL is called with a POST dict made up of the form fields.This is how most
Web forms operate, although they can technically submit their data via the GET method
as well. (This is not usually done, as it results in long, messy URLs for no good reason.)
In addition to GET and POST , HttpRequest objects expose a REQUEST dictionary, which
searches both of the former in an attempt to return the requested key.This can be conven-
ient in situations where a given key/value pair can be sent to your view via either
method, and you’re unsure which was used; however, due to the Pythonic philosophy of
“explicit is better than implicit,” most experienced Django programmers tend not to use
this feature.

Cookies and Sessions
Following GET and POST, the next most commonly used aspect of request objects is
request.COOKIES , which is yet another dictionary whose key/value pairs expose the
HTTP cookies stored in the request. Cookies are a simple method by which Web pages
can STORE persistent pieces of information in a USER"S BROWSER—they power most authenti-
cation systems on the Web and are used by some commercial sites to track a user’s surfing
history.

Most cookies, generally, are used to enable a feature called sessions.This means that a
Web page can ask the browser for a value identifying the user (which is set when the user
first connects to the site or when the user logs in), and then uses this information to cus-
tomize the behavior of the page for that user. Because cookies are easily manipulated on
the client side, thus making it unsafe to store any real data in them, most Web sites store
information in a server-side session object (usually via the site’s database) and leave only a
unique session ID in the cookie itself.

session
--------
Sessions are often used to implement state, as the HTTP protocol is by nature state-
less—each request/response cycle stands by itself and has no knowledge of previous
requests nor ways to pass information to later ones.With sessions,Web applications can
work around this, storing items of data—such as messages to the user about whether sub-
mitting a form successfully saved her changes—on the server and sending them to the
user in subsequent responses.

In Django, sessions are presented as yet another dictionary-like attribute of the
HttpRequest object, request.session (note the session is lowercase, unlike the
others—because sessions are not actually part of the HTTP protocol). Like the COOKIES
attribute before it, session can be both read from and written to by one’s Python code.

When first presented to your code, it contains the session as read from the database based
on the user’s session cookie. If written to, it saves your changes back to the database, so
they can be read later.

Other Server Variables
----------------------
The previous aspects of the request object are the most often used; however, requests con-
tain a host of other, usually read-only variables, some of which are part of the HTTP
specification and others which are convenience attributes specific to Django.The follow-
ing are all direct attributes of the request object:
1. path 	: The portion of the URL after the domain, for example, /blog/2007/11/04/ ;
		      this is also the string that is handled by the URLconf.
2. method 	: One of two strings, ’GET’ or ’POST’ , specifying which HTTP request
			  method was used in this request.
3. encoding : A string specifying the encoding character set used to decode any form
			  submission data.
4. FILES 	: A dict-like object containing any files uploaded via a file input form field,
			  each represented as another dictionary with key/value pairs for the filename, the
			  content type, and the file content itself.
5. META 	: Another dictionary, containing the HTTP server/request variables not handled by 
			  the other aspects of the request, including CONTENT_LENGTH , HTTP_REFERER ,
			  REMOTE_ADDR , SERVER_NAME , and so forth.
6. user 	: The Django authentication user, which only appears if your site has Django’s
			  authentication mechanisms activated.
7. raw_post_data :The raw, unfiltered version of the POST data contained within this
		      request.The use of request.POST is almost always preferable over accessing
		      request.raw_post_data , but it’s here for examination by those with advanced needs.
